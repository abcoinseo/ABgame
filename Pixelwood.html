<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pixel Wood Stacker Pro</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --primary-bg: #0A0F2C; 
            --secondary-bg: #1f2a40; 
            --accent-cyan: #00FFFF; 
            --text-main: #FFFFFF; 
            --electric-blue: #00BFFF; 
            --text-secondary: #B0BEC5; 
            --shadow-color: #007A7A; 
            --danger-color: #FF3B30; 
            --success-color: var(--electric-blue); 
            
            --block-base-shadow: rgba(0,0,0,0.25); /* Darker shadow for wood blocks */
            --block-edge-highlight: rgba(255,255,255,0.1);

            --game-bg: #87CEEB; /* Light Sky Blue for game canvas */
            --perfect-stack-glow: #FFD700; /* Gold */


            --font-main: 'Press Start 2P', cursive;
        }

        body {
            background-color: var(--primary-bg);
            color: var(--text-main);
            font-family: var(--font-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            text-align: center;
            padding: 10px;
            box-sizing: border-box;
        }

        .screen {
            display: none; 
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 400px; 
            padding: 20px;
            box-sizing: border-box;
        }
        .screen.active {
            display: flex;
        }

        h1, h2 {
            color: var(--accent-cyan);
            text-shadow: 2px 2px 0px var(--shadow-color);
        }
        h1 { font-size: 2em; margin-bottom: 20px; }
        h2 { font-size: 1.6em; margin-bottom: 15px; }

        p {
            font-size: 0.9em;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        button {
            font-family: var(--font-main);
            background-color: var(--success-color);
            color: var(--primary-bg); 
            border: none;
            padding: 12px 20px;
            font-size: 0.9em;
            cursor: pointer;
            border-radius: 3px; 
            text-transform: uppercase;
            box-shadow: 0 3px 0 #008bb2; 
            transition: all 0.1s ease;
            margin: 10px 5px;
            min-width: 150px;
            border: 1px solid var(--accent-cyan); 
        }
        button:hover { background-color: var(--accent-cyan); color: var(--primary-bg); box-shadow: 0 3px 0 var(--shadow-color); }
        button:active { transform: translateY(2px); box-shadow: 0 1px 0 var(--shadow-color); }
        
        button.danger { background-color: var(--danger-color); box-shadow: 0 3px 0 #cc2f26; color: var(--text-main); }
        button.danger:hover { background-color: #ff5c52; box-shadow: 0 3px 0 #c0392b; }
        button.danger:active { transform: translateY(2px); box-shadow: 0 1px 0 #c0392b; }


        #homeScreen .logo {
            font-size: 2.0em; 
            margin-bottom: 30px;
        }
        #homeHighScore {
            font-size: 1.1em;
            background-color: var(--secondary-bg);
            padding: 10px 15px;
            border-radius: 3px;
            border: 2px solid var(--accent-cyan);
            margin-bottom: 25px;
            color: var(--accent-cyan);
        }

        #gameCanvasContainer {
            background-color: var(--secondary-bg);
            border: 3px solid var(--accent-cyan);
            box-shadow: 0 0 10px var(--accent-cyan), inset 0 0 8px rgba(0,0,0,0.3);
            padding: 4px;
            border-radius: 5px;
            position: relative; 
            margin-bottom: 15px;
            width: calc(100% - 8px); 
            max-width: 330px; 
            aspect-ratio: 320 / 480; 
        }
        
        canvas#gameCanvas {
            background-color: var(--game-bg); 
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; 
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .shake-effect {
            animation: shake 0.2s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0) rotate(-0.1deg); }
            20%, 80% { transform: translate3d(1px, 0, 0) rotate(0.1deg); }
            30%, 50%, 70% { transform: translate3d(-2px, 0, 0) rotate(-0.2deg); }
            40%, 60% { transform: translate3d(2px, 0, 0) rotate(0.2deg); }
        }

        #gameUI {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 320px;
            margin-bottom: 10px;
        }
        #scoreDisplay, #currentHighScoreDisplay {
            font-size: 0.9em;
            background-color: var(--secondary-bg);
            padding: 8px 12px;
            border-radius: 3px;
            border: 1px solid var(--accent-cyan);
            color: var(--text-main);
        }
        #currentHighScoreDisplay { color: var(--text-secondary); }

        #gameOverScreen p {
            font-size: 1.1em;
        }
        #finalScoreDisplay {
            color: var(--accent-cyan);
            font-weight: bold;
            font-size: 1.2em;
        }
        
        #instructions {
            font-size: 0.8em;
            max-width: 320px;
            line-height: 1.7;
            background-color: rgba(0,0,0,0.25);
            padding: 12px;
            border-radius: 3px;
            margin-top: 15px;
            border: 1px solid var(--shadow-color);
        }

        @media (max-width: 480px) {
            h1 { font-size: 1.5em; }
            h2 { font-size: 1.2em; }
            #homeScreen .logo { font-size: 1.6em; }
            button { padding: 10px 15px; font-size: 0.75em; min-width: 110px; }
            #gameCanvasContainer { padding: 2px; border-width: 2px; }
            #scoreDisplay, #currentHighScoreDisplay { font-size: 0.7em; padding: 6px 10px; }
            #instructions { font-size: 0.65em; line-height: 1.6;}
        }
    </style>
</head>
<body>

    <div id="homeScreen" class="screen active">
        <h1 class="logo">Pixel Wood Stacker Pro</h1>
        <p id="homeHighScore">High Score: 0</p>
        <button id="startGameButton">Start Game</button>
        <div id="instructions">
            <b><u>Mobile:</u></b><br>
            <b>Touch & Drag</b> to Move Block<br>
            <b>Tap Screen</b> to Drop Block<br>
            <b><u>Desktop:</u></b><br>
            <b>Left/Right Arrows</b> or <b>A/D</b>: Move<br>
            <b>Space</b>, <b>Down Arrow</b>, or <b>S</b>: Drop<br>
            Stack perfectly for max width!
        </div>
    </div>

    <div id="gameScreen" class="screen">
        <div id="gameUI">
            <span id="scoreDisplay">Score: 0</span>
            <span id="currentHighScoreDisplay">High: 0</span>
        </div>
        <div id="gameCanvasContainer">
            <canvas id="gameCanvas"></canvas>
        </div>
    </div>

    <div id="gameOverScreen" class="screen">
        <h2>Game Over!</h2>
        <p>Final Score: <span id="finalScoreDisplay">0</span></p>
        <button id="restartGameButton">Play Again</button>
        <button id="backToMenuButton" class="danger">Main Menu</button>
    </div>

    <script>
        const homeScreen = document.getElementById('homeScreen');
        const gameScreen = document.getElementById('gameScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startGameButton = document.getElementById('startGameButton');
        const restartGameButton = document.getElementById('restartGameButton');
        const backToMenuButton = document.getElementById('backToMenuButton');
        const homeHighScoreDisplay = document.getElementById('homeHighScore');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const currentHighScoreDisplay = document.getElementById('currentHighScoreDisplay');
        const finalScoreDisplay = document.getElementById('finalScoreDisplay');
        const gameCanvasContainer = document.getElementById('gameCanvasContainer');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const CANVAS_WIDTH = 320;
        const CANVAS_HEIGHT = 480;
        const BLOCK_HEIGHT = 20;
        const INITIAL_BLOCK_WIDTH = 120;
        const MIN_BLOCK_WIDTH = 15;
        const BLOCK_START_Y = -BLOCK_HEIGHT; // Start off-screen
        
        let BASE_FALL_SPEED = 1.2;
        let currentFallSpeed = BASE_FALL_SPEED;
        const FAST_FALL_MULTIPLIER = 7;
        const MOVE_SPEED = 8; 
        const PERFECT_STACK_TOLERANCE = 2;

        const WOOD_COLORS = [
            { base: '#A0522D', grainDark: '#6B3E1F', grainLight: '#D27D2D', type: 'Oak' }, // SaddleBrown tones
            { base: '#CD853F', grainDark: '#8B5A2B', grainLight: '#F4A460', type: 'Pine' }, // Peru tones
            { base: '#D2B48C', grainDark: '#A08C6D', grainLight: '#E0C9A6', type: 'Birch' }, // Tan tones
            { base: '#5E4028', grainDark: '#3D2A1A', grainLight: '#7A5839', type: 'Walnut' }  // Darker wood
        ];

        let score = 0;
        let highScore = 0;
        let stackedBlocks = [];
        let currentBlock = null;
        let isGameOver = true;
        let gameLoopId = null;
        let particles = [];
        let difficultyLevel = 0;

        let touchStartX = 0;
        let touchStartY = 0;
        let initialBlockX = 0;
        let isDragging = false;
        let touchStartTime = 0;

        // --- Sound Effects Library ---
        // IMPORTANT: Replace 'null' with actual Audio objects, e.g., new Audio('sounds/place.wav');
        // Find royalty-free sounds at sites like: freesound.org, opengameart.org, or use a chiptune generator.
        const sounds = {
            start: null,   // e.g., new Audio('sounds/start.wav');
            place: null,   // e.g., new Audio('sounds/place_wood.wav');
            perfect: null, // e.g., new Audio('sounds/perfect_stack.wav');
            fastDrop: null,// e.g., new Audio('sounds/fast_drop.wav');
            fallOff: null, // e.g., new Audio('sounds/fall_off.wav');
            gameOver: null,// e.g., new Audio('sounds/game_over_wood.wav');
            click: null,   // e.g., new Audio('sounds/ui_click.wav');
        };

        function playSound(soundName) {
            if (sounds[soundName] && sounds[soundName].readyState >= 2) { // Check if ready
                sounds[soundName].currentTime = 0;
                sounds[soundName].play().catch(e => console.warn("Audio play failed for " + soundName + ":", e));
            }
        }
        
        class Particle {
            constructor(x, y, color, size, speed, life = 60, type = 'dust') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.size = Math.random() * size + Math.floor(size/2);
                this.initialSize = this.size;
                this.speedX = (Math.random() - 0.5) * speed + (Math.random() - 0.5) * 0.5; // Add slight horizontal drift
                this.speedY = (Math.random() * -0.5 - 0.2) * speed; // Upward burst initially
                this.color = color;
                this.life = life + Math.random() * life * 0.5; 
                this.initialLife = this.life;
                this.gravity = 0.05 + Math.random() * 0.05;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                this.life--;
                if (this.type === 'splinter') { // Splinters might shrink
                    this.size = Math.max(1, this.initialSize * (this.life / this.initialLife));
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                const currentAlpha = Math.max(0, this.life / this.initialLife);
                ctx.globalAlpha = currentAlpha * currentAlpha; // Fade out quadratically
                ctx.fillRect(Math.floor(this.x - this.size/2), Math.floor(this.y - this.size/2), Math.max(1,Math.floor(this.size)), Math.max(1,Math.floor(this.size)));
                ctx.globalAlpha = 1;
            }
        }

        function createParticles(x, y, count, color, size = 4, speed = 2, life = 60, particleType = 'dust') {
            for (let i = 0; i < count; i++) {
                let pColor = color;
                if (Array.isArray(color)) { // If color is an array, pick one randomly
                    pColor = color[Math.floor(Math.random() * color.length)];
                }
                particles.push(new Particle(x, y, pColor, size, speed, life, particleType));
            }
        }

        function showScreen(screenElement) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            screenElement.classList.add('active');
            playSound('click');
        }

        function initApp() {
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            ctx.imageSmoothingEnabled = false; 

            loadHighScore();
            updateHighScoreDisplays();
            showScreen(homeScreen);

            startGameButton.addEventListener('click', () => { playSound('start'); startGame(); });
            restartGameButton.addEventListener('click', () => { playSound('start'); startGame(); });
            backToMenuButton.addEventListener('click', () => {
                loadHighScore(); 
                updateHighScoreDisplays();
                showScreen(homeScreen);
            });
            
            setupInputListeners();
        }

        function loadHighScore() {
            highScore = parseInt(localStorage.getItem('pixelWoodStackerProHighScore')) || 0;
        }

        function saveHighScore() {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('pixelWoodStackerProHighScore', highScore);
            }
        }
        
        function updateHighScoreDisplays() {
            homeHighScoreDisplay.textContent = `High Score: ${highScore}`;
            currentHighScoreDisplay.textContent = `High: ${highScore}`;
        }

        function startGame() {
            isGameOver = false;
            score = 0;
            difficultyLevel = 0;
            BASE_FALL_SPEED = 1.2; 
            currentFallSpeed = BASE_FALL_SPEED;
            stackedBlocks = [];
            particles = [];
            updateScoreDisplay();
            updateHighScoreDisplays();
            
            const baseBlockWidth = CANVAS_WIDTH * 0.9; 
            const baseBlock = {
                x: (CANVAS_WIDTH - baseBlockWidth) / 2,
                y: CANVAS_HEIGHT - BLOCK_HEIGHT,
                width: baseBlockWidth,
                height: BLOCK_HEIGHT,
                colorSet: getRandomWoodColor()
            };
            stackedBlocks.push(baseBlock);

            spawnNewBlock(INITIAL_BLOCK_WIDTH);
            
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoop();
            showScreen(gameScreen);
        }
        
        function getRandomWoodColor() {
            return WOOD_COLORS[Math.floor(Math.random() * WOOD_COLORS.length)];
        }

        function spawnNewBlock(width) {
            currentBlock = {
                x: Math.random() * (CANVAS_WIDTH - width), 
                y: BLOCK_START_Y, 
                width: Math.max(width, MIN_BLOCK_WIDTH),
                height: BLOCK_HEIGHT,
                colorSet: getRandomWoodColor(),
                vy: currentFallSpeed,
                isFastDropping: false
            };
        }
        
        function gameLoop() {
            if (isGameOver) {
                handleGameOver();
                return;
            }
            updateGame();
            drawGame();
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function updateGame() {
            if (!currentBlock) return;
            currentBlock.y += currentBlock.vy;

            const topStackedBlock = stackedBlocks[stackedBlocks.length - 1];
            if (currentBlock.y + currentBlock.height >= topStackedBlock.y) {
                processBlockLanding(topStackedBlock);
            }

            if (currentBlock.y > CANVAS_HEIGHT + BLOCK_HEIGHT * 3) { 
                playSound('fallOff');
                createBlockFallOffParticles(currentBlock);
                endGame(false); // False, because game over wasn't due to a bad stack
            }
            
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function createBlockFallOffParticles(block) {
            const particleColors = [block.colorSet.grainLight, block.colorSet.grainDark];
            createParticles(block.x + block.width / 2, CANVAS_HEIGHT, 25, particleColors, 5, 3, 70, 'splinter');
        }

        function processBlockLanding(topStackedBlock) {
            const overlapStart = Math.max(currentBlock.x, topStackedBlock.x);
            const overlapEnd = Math.min(currentBlock.x + currentBlock.width, topStackedBlock.x + topStackedBlock.width);
            let newWidth = overlapEnd - overlapStart;

            if (newWidth > 0) { 
                currentBlock.y = topStackedBlock.y - BLOCK_HEIGHT;
                currentBlock.x = overlapStart;
                currentBlock.width = newWidth;
                
                stackedBlocks.push({...currentBlock});
                score++;
                updateScoreDisplay();
                updateDifficulty();
                
                const particleX = currentBlock.x + newWidth / 2;
                const particleY = currentBlock.y + BLOCK_HEIGHT / 2;

                const alignmentDiff = Math.abs(currentBlock.x - topStackedBlock.x);
                if (alignmentDiff <= PERFECT_STACK_TOLERANCE && newWidth >= topStackedBlock.width - PERFECT_STACK_TOLERANCE * 1.5) {
                    newWidth = topStackedBlock.width; 
                    currentBlock.width = newWidth; 
                    stackedBlocks[stackedBlocks.length-1].width = newWidth; 
                    
                    playSound('perfect');
                    createParticles(particleX, particleY, 30, 'var(--perfect-stack-glow)', 6, 3.5, 80, 'sparkle');
                } else {
                    playSound('place');
                    createParticles(particleX, particleY, 10 + Math.floor(newWidth/10), currentBlock.colorSet.grainLight, 4, 2, 50);
                    triggerScreenShake(100, 1);
                }

                if (newWidth < MIN_BLOCK_WIDTH) { 
                    endGame(true); // True, game over due to small stack
                    return;
                }
                
                spawnNewBlock(newWidth);
                
                if (stackedBlocks.length > 6 && stackedBlocks[stackedBlocks.length -1].y < CANVAS_HEIGHT * 0.3) {
                    shiftBlocksDown();
                }

            } else { 
                playSound('fallOff');
                createBlockFallOffParticles(currentBlock);
                endGame(false); // False, game over due to missing stack
            }
        }
        
        function updateDifficulty() {
            if (score > 0 && score % 3 === 0 && difficultyLevel < 20) { 
                difficultyLevel++;
                BASE_FALL_SPEED = Math.min(BASE_FALL_SPEED + 0.08, 3.5); 
                currentFallSpeed = currentBlock && currentBlock.isFastDropping ? BASE_FALL_SPEED * FAST_FALL_MULTIPLIER : BASE_FALL_SPEED;
                if(currentBlock) currentBlock.vy = currentFallSpeed;
            }
        }

        function shiftBlocksDown() {
            const shiftAmount = BLOCK_HEIGHT * 2.5;
            stackedBlocks.forEach(block => block.y += shiftAmount);
            if(currentBlock) currentBlock.y += shiftAmount; 
            particles.forEach(p => p.y += shiftAmount);
            stackedBlocks = stackedBlocks.filter(block => block.y < CANVAS_HEIGHT + BLOCK_HEIGHT * 4);
        }

        function triggerScreenShake(duration = 150, intensity = 1) {
            gameCanvasContainer.classList.add('shake-effect');
            setTimeout(() => {
                gameCanvasContainer.classList.remove('shake-effect');
            }, duration);
        }

        function endGame(dueToSmallStack = true) {
            if(isGameOver) return; // Prevent multiple calls
            isGameOver = true;
            saveHighScore();
            playSound('gameOver');

            let explosionX, explosionY, explosionColors;
            const lastLandedBlock = stackedBlocks[stackedBlocks.length-1];

            if (currentBlock && !dueToSmallStack) { // Block fell off screen
                 explosionX = currentBlock.x + currentBlock.width/2;
                 explosionY = currentBlock.y + currentBlock.height/2;
                 explosionColors = [currentBlock.colorSet.base, currentBlock.colorSet.grainDark, currentBlock.colorSet.grainLight];
            } else if (lastLandedBlock) { // Stack became too small or player initiated game over
                 explosionX = lastLandedBlock.x + lastLandedBlock.width/2;
                 explosionY = lastLandedBlock.y + lastLandedBlock.height/2;
                 explosionColors = [lastLandedBlock.colorSet.base, lastLandedBlock.colorSet.grainDark, lastLandedBlock.colorSet.grainLight];
            } else { // Should not happen, but as a fallback
                 explosionX = CANVAS_WIDTH/2;
                 explosionY = CANVAS_HEIGHT/2;
                 explosionColors = ['#888888', '#555555'];
            }
            
            // Large "Distory" particle explosion
            createParticles(explosionX, explosionY, 30, explosionColors, 10, 5, 100, 'splinter'); // Large chunks
            createParticles(explosionX, explosionY, 50, explosionColors, 4, 7, 120, 'splinter');  // Smaller, faster splinters
        }

        function handleGameOver() {
            cancelAnimationFrame(gameLoopId);
            finalScoreDisplay.textContent = score;
            updateHighScoreDisplays();
            showScreen(gameOverScreen);
        }

        function drawGame() {
            ctx.fillStyle = 'var(--game-bg)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            stackedBlocks.forEach(block => drawWoodBlock(block));
            if (currentBlock && !isGameOver) {
                drawWoodBlock(currentBlock);
            }
            particles.forEach(p => p.draw());
        }

        function drawWoodBlock(block) {
            const { x, y, width, height, colorSet } = block;
            if (y + height < -BLOCK_HEIGHT*3 || y > CANVAS_HEIGHT + BLOCK_HEIGHT*3) return;

            const ix = Math.floor(x);
            const iy = Math.floor(y);
            const iw = Math.floor(width);
            const ih = Math.floor(height);

            // Base color
            ctx.fillStyle = colorSet.base;
            ctx.fillRect(ix, iy, iw, ih);

            // Darker grain (more pixelated)
            ctx.fillStyle = colorSet.grainDark;
            for (let gy = 0; gy < ih; gy += Math.max(2, Math.floor(ih / 5))) { // Horizontal grain lines
                if (iw > 3 && ih > 1) {
                     const lineOffset = Math.floor(Math.random() * 3) -1; // Wavy lines
                     ctx.fillRect(ix + 1, Math.min(iy + ih -1, iy + gy + lineOffset), Math.max(1, iw - 2), 1);
                }
            }
             for (let gx = 0; gx < iw; gx += Math.max(3, Math.floor(iw / 8))) { // Short vertical grain bits
                 if (iw > 2 && ih > 3) {
                    const bitHeight = Math.floor(Math.random() * (ih/2)) + 2;
                    ctx.fillRect(ix + gx, iy + Math.floor(Math.random() * (ih - bitHeight)), 1, bitHeight);
                 }
             }

            // Lighter highlights/grain spots
            ctx.fillStyle = colorSet.grainLight;
            const numHighlights = Math.floor(iw * ih / 100) + 3;
            for (let k = 0; k < numHighlights; k++) {
                if (iw > 1 && ih > 1) {
                    ctx.fillRect(ix + Math.floor(Math.random() * (iw - 1)), iy + Math.floor(Math.random() * (ih - 1)), 1, 1);
                }
            }
            
            // Pixel border/shadow (darker base)
            ctx.fillStyle = 'var(--block-base-shadow)';
            if (iw > 1 && ih > 1) {
                ctx.fillRect(ix + iw -1, iy + 1, 1, ih -1); // Right shadow
                ctx.fillRect(ix + 1, iy + ih -1, iw -1, 1); // Bottom shadow
            }
            // Softer edge highlight
            ctx.fillStyle = 'var(--block-edge-highlight)';
            if (iw > 1 && ih > 1) {
                ctx.fillRect(ix, iy, iw, 1); // Top highlight
                ctx.fillRect(ix, iy, 1, ih); // Left highlight
            }
        }
        
        function updateScoreDisplay() {
            scoreDisplay.textContent = `Score: ${score}`;
        }

        function handleKeyDown(e) {
            if (isGameOver || !currentBlock) return;
            let keyProcessed = true;
            switch (e.key.toLowerCase()) {
                case 'arrowleft': case 'a': currentBlock.x -= MOVE_SPEED; break;
                case 'arrowright': case 'd': currentBlock.x += MOVE_SPEED; break;
                case 'arrowdown': case 's': case ' ': 
                    if (!currentBlock.isFastDropping) {
                        currentBlock.vy = BASE_FALL_SPEED * FAST_FALL_MULTIPLIER;
                        currentBlock.isFastDropping = true;
                        playSound('fastDrop');
                    }
                    break;
                default: keyProcessed = false;
            }
            if (keyProcessed) e.preventDefault();
            if (currentBlock.x < 0) currentBlock.x = 0;
            if (currentBlock.x + currentBlock.width > CANVAS_WIDTH) currentBlock.x = CANVAS_WIDTH - currentBlock.width;
        }

        function handleTouchStart(e) {
            if (isGameOver || !currentBlock) return;
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            initialBlockX = currentBlock.x;
            isDragging = true;
            touchStartTime = Date.now();
        }

        function handleTouchMove(e) {
            if (!isDragging || isGameOver || !currentBlock) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const deltaXCanvas = (touch.clientX - touchStartX) * scaleX;
            currentBlock.x = initialBlockX + deltaXCanvas;
            if (currentBlock.x < 0) currentBlock.x = 0;
            if (currentBlock.x + currentBlock.width > CANVAS_WIDTH) currentBlock.x = CANVAS_WIDTH - currentBlock.width;
        }

        function handleTouchEnd(e) {
            if (isGameOver || !currentBlock || !e.changedTouches[0]) return; // Added check for changedTouches
            const touchDuration = Date.now() - touchStartTime;
            const touch = e.changedTouches[0];
            const deltaX = Math.abs(touch.clientX - touchStartX);
            const deltaY = Math.abs(touch.clientY - touchStartY);

            if (isDragging && touchDuration < 200 && deltaX < 20 && deltaY < 20) { // Adjusted for better tap detection
                if (!currentBlock.isFastDropping) {
                    currentBlock.vy = BASE_FALL_SPEED * FAST_FALL_MULTIPLIER;
                    currentBlock.isFastDropping = true;
                    playSound('fastDrop');
                }
            }
            isDragging = false;
        }

        function setupInputListeners() {
            window.addEventListener('keydown', handleKeyDown);
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        }

        window.addEventListener('load', initApp);
    </script>
</body>
</html>
